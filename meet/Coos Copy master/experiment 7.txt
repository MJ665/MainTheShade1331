                              experiment 7

AIM: To implement FIFO page replacement technique.

DESCRIPTION:
Page replacement algorithms are an important part of virtual memory management, and it helps the OS to decide which memory page can be moved out making space for the currently needed page. However, the ultimate objective of all page replacement algorithms is to reduce the number of page faults.
FIFO-This is the simplest page replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced page in the front of the queue is selected for removal.
LRU-In this algorithm, page will be replaced which is least recently used.
OPTIMAL- In this algorithm, pages are replaced which would not be used for the longest duration of time in the future. This algorithm will give us less page fault when compared to other page replacement algorithms.
A.	FIRST IN FIRST OUT ALGORITHM:
1.	Start the process
2.	Read number of pages n
3.	Read number of pages no
4.	Read page numbers into an array a[i]
5.	Initialize avail[i]=0 .to check page hit
6.	Replace the page with circular queue, while re-placing check page availability in the frame Place avail[i]=1 if page is placed in the frame Count page faults 7. Print the results.
8. Stop the process.

SOURCE CODE:
#include <bits/stdc++.h> using namespace std;
int fr[3];

void display() {
for (int i = 0; i < 3; i++) { cout << fr[i] << '\t';
}
cout << '\n';
 
}

int main() {
int i, j, page[12] = {2, 3, 2, 1, 5, 2, 4, 5, 3, 2, 5,
2};	int flag1 = 0, flag2 = 0, pf = 0, frsize = 3, top = 0;	for (i = 0; i < 3; i++) {	fr[i] = -1;
}

for (j = 0; j < 12; j++) {	flag1 = 0; flag2 = 0;

for (i = 0; i < 3;
i++) {	if (fr[i]
== page[j])
{	flag1 = 1; flag2 = 1;
break;
}
}

if (flag1 == 0)
{	for (i = 0; i < frsize; i++) {		if (fr[i] == -
1) {	fr[i] =
page[j];		flag2 = 1;	break;
}
}
}

if (flag2 == 0)
{	fr[top] =
page[j];
top++;	pf++; if (top >= frsize) top = 0;
}

display();
}

cout << "Number of page faults: " << pf + frsize << endl; return 0;
}
output___________________________________________________

B.	Least Recently Used (LRU) ALGORITHM:
Let capacity be the number of pages that memory can hold. Let set be the current set of pages
in memory.
1- Start traversing the pages.
i)	If set holds less pages than capacity.
a)	Insert page into the set one by one until the size of set reaches capacity or all page requests are processed.
b)	Simultaneously maintain the recent occurred index of each page in a map called indexes.	c) Increment page fault
ii)	Else
If current page is present in set, do nothing.
Else
a)	Find the page in the set that was least recently used. We find it using index array. We basically need to replace the page with minimum index.
b)	Replace the found page with current page.
c)	Increment page faults.
d)	Update index of current page.
2.	Return page faults.

SOURCE CODE:
#include<bits/stdc++.h> using namespace std;
int pageFaults(int pages[], int n, int capacity)
{

unordered_set<int> s; unordered_map<int, int> indexes;	int page_faults = 0;
for (int i=0; i<n; i++)
{
if (s.size() < capacity)
{
if (s.find(pages[i])==s.end())
{
s.insert(pages[i]); page_faults++;
}

}
else
{
 
indexes[pages[i]] = i;

if (s.find(pages[i]) == s.end())
{
 
int lru = INT_MAX, val;
for (auto it=s.begin(); it!=s.end(); it++)
{
if (indexes[*it] < lru)
{
lru = indexes[*it]; val = *it;
}
}
s.erase(val); s.insert(pages[i]); page_faults++;
}
indexes[pages[i]] = i;
}
}

return page_faults;
}
int main()
{
int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}; int
n = sizeof(pages)/sizeof(pages[0]);
 
int cap
cout << pageFaults(pages, n, capacity); return 0;
}
output____________________________________________________
C.	OPTIMAL ALGORITHM:

1.	If the referred page is already present, increment hit count.
2.	If not present, find a page that is never referenced in future. If such a page exists, replace this page with a new page. If no such page exists, find a page that is referenced farthest in future. Replace this page with a new page.
 

SOURCE CODE:
#include <bits/stdc++.h> using namespace std;
bool search(int key, vector<int>& fr)
{
for (int i = 0; i < fr.size(); i++) if (fr[i] == key)
return true;
return false;
}
int predict(int pg[], vector<int>& fr, int pn, int index)
{
int res = -1, farthest = index; for (int i = 0; i < fr.size(); i++) {
int j;
for (j = index; j < pn; j++)
{	if (fr[i] == pg[j])
{
if (j > farthest) {
farthest = j;
res = i;
 
break;
}
}
if (j == pn)
return i;
}
return (res == -1) ? 0 : res;
}
void optimalPage(int pg[], int pn, int fn)
{
vector<int> fr; int hit = 0;
for (int i = 0; i < pn; i++) {
if (search(pg[i], fr)) {
hit++;

else {
 
continue;
}
if (fr.size() < fn)
fr.push_back(pg[i]);

int j = predict(pg, fr, pn, i + 1); fr[j] = pg[i];
 
}
}
cout << "No. of hits = " << hit << endl;
cout << "No. of misses = " << pn - hit << endl;
}
int main()
{
int pg[] = { 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2 };
int pn = sizeof(pg) / sizeof(pg[0]); int fn = 4; optimalPage(pg, pn, fn);
return 0;
}
output______________________________________________

In conclusion, page replacement algorithms are vital for minimizing page faults in virtual memory management. The First-In-First-Out (FIFO) algorithm, while straightforward, may not be the most efficient choice for all scenarios, as it may suffer from the "Belady's Anomaly." More advanced algorithms like LRU and OPTIMAL are often preferred when the goal is to reduce page faults by prioritizing frequently used pages in memory. The choice of the algorithm should align with the specific system requirements and workload characteristics.

