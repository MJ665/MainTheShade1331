                         experiment 6

AIM: Write a C program to simulate the following non-preemptive CPU scheduling algorithms to find turnaround time and waiting time for the above problem. A) Round Robin b) Priority
THEORY:
ROUND ROBIN CPU SCHEDULING ALGORITHM:
For round robin scheduling algorithm, read the number of processes/jobs in the system, their CPU burst times, and the size of the time slice. Time slices are assigned to each process in equal portions and in circular order, handling all processes execution. This allows every process to get an equal chance. Calculate the waiting time and turnaround time of each of the processes accordingly.
PRIORITY CPU SCHEDULING ALGORITHM:
For priority scheduling algorithm, read the number of processes/jobs in the system, their CPU burst times, and the priorities. Arrange all the jobs in order with respect to their priorities. There may be two jobs in queue with the same priority, and then FCFS approach is to be performed.
Each process will be executed according to its priority. Calculate the waiting time and turnaround time of each of the processes accordingly.
ROUND ROBIN CPU SCHEDULING ALGORITHM
1.	Start with a list of processes, where each process is represented by its process ID.

2.	For each process, gather the following information:
Burst time (time required for the process to complete its execution).

3.	Determine the quantum time slice (a fixed time interval for which each process will run before moving to the next).

4.	Initialize variables:

Create an array rem_bt[] to store remaining burst times for each process. Initialize rem_bt[] with the burst times of the processes.
Set the current time t to 0.
Create arrays to store waiting times wt[] and turnaround times tat[].

5.	Start a loop that will continue until all processes are done.
Inside the loop, set a boolean variable done to true (initially assume that all processes are done).
 

6.	For each process in the list of processes:
If the remaining burst time rem_bt[i] for the process is greater than 0, then: Set done to false (at least one process is not done).
If rem_bt[i] is greater than the quantum time slice: Increment the current time t by the quantum time slice.
Decrement the remaining burst time rem_bt[i] by the quantum time slice.
Otherwise (if rem_bt[i] is less than or equal to the quantum time slice): Increment the current time t by rem_bt[i].
Calculate the waiting time for the process wt[i] as t - burst_time[i].	Set rem_bt[i] to 0, indicating that the process is done.

7.	If done is still true after processing all processes, exit the loop as all processes are done.

8.	Calculate the turnaround time for each process:
For each process, tat[i] = burst_time[i] + wt[i].

9.	Calculate the total waiting time total_wt and total turnaround time total_tat for all processes.

10.	Display the results, including the process ID, burst time, waiting time, and turnaround time for each process, as well as the average waiting time and average turnaround time for all processes.

11.	End.
PRIORITY CPU SCHEDULING ALGORITHM
1.	Initialize arrays and variables:

p[20]: Process IDs
bt[20]: Burst times (time required for the process to complete its execution) pri[20]: Priorities for each process wt[20]: Waiting times for each process tat[20]: Turnaround times for each process i: Loop counter k: Loop counter n: Total number of processes
temp: Temporary variable for swapping

2.	Prompt the user to enter the number of processes, n.

3.	For each process from 0 to n-1, do the following: Initialize the process ID, p[i], with i.
 

Prompt the user to enter the burst time and priority for each process.

4.	Implement the Priority Scheduling algorithm to prioritize processes based on their priorities: Use nested loops to compare priorities and rearrange the processes, burst times, and priorities in ascending order of priority.
If pri[i] is greater than pri[k] for a pair of processes i and k, swap the elements in p[], bt[], and pri[].

5.	Calculate waiting times (wt) and turnaround times (tat) for each process: Initialize wtavg and tatavg to zero.
For process 0, wt[0] is zero, and tat[0] is equal to its burst time (bt[0]).
For each process from 1 to n-1, calculate wt[i] as the sum of the previous waiting time and burst time (wt[i-1] + bt[i-1]), and tat[i] as	the sum of the previous turnaround time and burst time (tat[i-1] + bt[i]). Update wtavg by adding wt[i] and tatavg by adding tat[i] for each process.

6.	Display the results:
Print a table with columns for process ID, priority, burst time, waiting time, and turnaround time. Display the calculated values for each process in the table.
Calculate and display the average waiting time and average turnaround time for all processes by dividing wtavg and tatavg by n.

7.	End.

Implementation for Round robin CPU scheduling:
#include <iostream> using namespace std;

// Function to calculate the waiting time for each process
void findWaitingTime(int processes[], int n, int bt[], int wt[], int quantum) { int rem_bt[n];
for (int i = 0; i < n; i++) rem_bt[i] = bt[i];

int t = 0;
 
while (1) {
bool done = true;

for (int i = 0; i < n; i++) { if (rem_bt[i] > 0) {
done = false;

if (rem_bt[i] > quantum) { t += quantum; rem_bt[i] -= quantum;
} else {
t += rem_bt[i]; wt[i] = t - bt[i]; rem_bt[i] = 0;
}
}
}
if (done == true) break;
}
}

// Function to calculate the turnaround time for each process
void findTurnAroundTime(int processes[], int n, int bt[], int wt[], int tat[]) { for (int i = 0; i < n; i++)
tat[i] = bt[i] + wt[i];

}
// Function to find and print the average waiting time and average turnaround time void findavgTime(int processes[], int n, int bt[], int quantum) {
int wt[n], tat[n], total_wt = 0, total_tat = 0;

findWaitingTime(processes, n, bt, wt, quantum); findTurnAroundTime(processes, n, bt, wt, tat);

cout << "Process\tBurst Time\tWaiting Time\tTurnaround Time\n";

for (int i = 0; i < n; i++) { total_wt += wt[i]; total_tat += tat[i];
cout << "P" << processes[i] << "\t" << bt[i] << "\t\t" << wt[i] << "\t\t" << tat[i] << endl;
}

cout << "Average waiting time = " << (float)total_wt / (float)n;
cout << "\nAverage turnaround time = " << (float)total_tat / (float)n;
}

int main() {
int processes[] = {1, 2, 3};
int n = sizeof(processes) / sizeof(processes[0]); int burst_time[] = {24, 3, 3};
int quantum = 3;

findavgTime(processes, n, burst_time, quantum);
 
return 0;
}
output_____________________________________________________

Implementation for Priority CPU scheduling:
#include <bits/stdc++.h> using namespace std;

int main() {
int p[20], bt[20], pri[20], wt[20], tat[20], i, k, n, temp; float wtavg, tatavg;

cout << "Enter the number of processes --- "; cin >> n;

for(i = 0; i < n; i++) { p[i] = i;
cout << "Enter the Burst Time & Priority of Process " << i << "
--- ";	cin >> bt[i] >> pri[i];
}

for(i = 0; i < n; i++)
{ for(k = i + 1; k < n; k++) {	if (pri[i] >
pri[k]) {		temp = p[i];	p[i] = p[k]; p[k] = temp;
temp = bt[i]; bt[i] = bt[k]; bt[k] = temp; temp = pri[i]; pri[i] = pri[k];
 

pri[k] = temp;
}
}
}

tavg = wt[0] = 0; tatavg = tat[0] = bt[0]; for(i = 1; i < n; i++)
{         wt[i] = wt[i - 1] +
bt[i - 1];	tat[i] =
tat[i - 1]   +   bt[i]; wtavg = wtavg + wt[i];
tatavg = tatavg + tat[i];
}

cout << "\nPROCESS\t\tPRIORITY\tBURST TIME\tWAITING TIME\tTURNAROUND
TIME" << endl;

for(i = 0; i < n; i++) {
cout << p[i] << "\t\t" << pri[i] << "\t\t" << bt[i] << "\t\t" << wt[i] << "\t\t" << tat[i] << endl;
}

cout << "Average Waiting Time is --- " << wtavg / n << endl;	cout << "Average Turnaround Time is --- " << tatavg
/ n << endl;

return 0;
}
Output:

In conclusion, Round Robin CPU Scheduling is a fair method that divides CPU time into fixed slices, ensuring process fairness. It's suitable for balanced workloads and throughput-focused systems. However, the choice of the time slice is critical, and other algorithms like Priority Scheduling may be better for prioritizing tasks. The choice of algorithm depends on system needs and workloads.

